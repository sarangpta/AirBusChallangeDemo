{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nvar t;\n\nconst i = globalThis.trustedTypes,\n      s = i ? i.createPolicy(\"lit-html\", {\n  createHTML: t => t\n}) : void 0,\n      e = `lit$${(Math.random() + \"\").slice(9)}$`,\n      o = \"?\" + e,\n      n = `<${o}>`,\n      l = document,\n      h = (t = \"\") => l.createComment(t),\n      r = t => null === t || \"object\" != typeof t && \"function\" != typeof t,\n      d = Array.isArray,\n      u = t => {\n  var i;\n  return d(t) || \"function\" == typeof (null === (i = t) || void 0 === i ? void 0 : i[Symbol.iterator]);\n},\n      c = /<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g,\n      v = /-->/g,\n      a = />/g,\n      f = />|[ \t\\n\f\\r](?:([^\\s\"'>=/]+)([ \t\\n\f\\r]*=[ \t\\n\f\\r]*(?:[^ \t\\n\f\\r\"'`<>=]|(\"|')|))|$)/g,\n      _ = /'/g,\n      m = /\"/g,\n      g = /^(?:script|style|textarea|title)$/i,\n      p = t => (i, ...s) => ({\n  _$litType$: t,\n  strings: i,\n  values: s\n}),\n      $ = p(1),\n      y = p(2),\n      b = Symbol.for(\"lit-noChange\"),\n      w = Symbol.for(\"lit-nothing\"),\n      T = new WeakMap(),\n      x = (t, i, s) => {\n  var e, o;\n  const n = null !== (e = null == s ? void 0 : s.renderBefore) && void 0 !== e ? e : i;\n  let l = n._$litPart$;\n\n  if (void 0 === l) {\n    const t = null !== (o = null == s ? void 0 : s.renderBefore) && void 0 !== o ? o : null;\n    n._$litPart$ = l = new N(i.insertBefore(h(), t), t, void 0, null != s ? s : {});\n  }\n\n  return l._$AI(t), l;\n},\n      A = l.createTreeWalker(l, 129, null, !1),\n      C = (t, i) => {\n  const o = t.length - 1,\n        l = [];\n  let h,\n      r = 2 === i ? \"<svg>\" : \"\",\n      d = c;\n\n  for (let i = 0; i < o; i++) {\n    const s = t[i];\n    let o,\n        u,\n        p = -1,\n        $ = 0;\n\n    for (; $ < s.length && (d.lastIndex = $, u = d.exec(s), null !== u);) $ = d.lastIndex, d === c ? \"!--\" === u[1] ? d = v : void 0 !== u[1] ? d = a : void 0 !== u[2] ? (g.test(u[2]) && (h = RegExp(\"</\" + u[2], \"g\")), d = f) : void 0 !== u[3] && (d = f) : d === f ? \">\" === u[0] ? (d = null != h ? h : c, p = -1) : void 0 === u[1] ? p = -2 : (p = d.lastIndex - u[2].length, o = u[1], d = void 0 === u[3] ? f : '\"' === u[3] ? m : _) : d === m || d === _ ? d = f : d === v || d === a ? d = c : (d = f, h = void 0);\n\n    const y = d === f && t[i + 1].startsWith(\"/>\") ? \" \" : \"\";\n    r += d === c ? s + n : p >= 0 ? (l.push(o), s.slice(0, p) + \"$lit$\" + s.slice(p) + e + y) : s + e + (-2 === p ? (l.push(void 0), i) : y);\n  }\n\n  const u = r + (t[o] || \"<?>\") + (2 === i ? \"</svg>\" : \"\");\n  if (!Array.isArray(t) || !t.hasOwnProperty(\"raw\")) throw Error(\"invalid template strings array\");\n  return [void 0 !== s ? s.createHTML(u) : u, l];\n};\n\nclass E {\n  constructor({\n    strings: t,\n    _$litType$: s\n  }, n) {\n    let l;\n    this.parts = [];\n    let r = 0,\n        d = 0;\n    const u = t.length - 1,\n          c = this.parts,\n          [v, a] = C(t, s);\n\n    if (this.el = E.createElement(v, n), A.currentNode = this.el.content, 2 === s) {\n      const t = this.el.content,\n            i = t.firstChild;\n      i.remove(), t.append(...i.childNodes);\n    }\n\n    for (; null !== (l = A.nextNode()) && c.length < u;) {\n      if (1 === l.nodeType) {\n        if (l.hasAttributes()) {\n          const t = [];\n\n          for (const i of l.getAttributeNames()) if (i.endsWith(\"$lit$\") || i.startsWith(e)) {\n            const s = a[d++];\n\n            if (t.push(i), void 0 !== s) {\n              const t = l.getAttribute(s.toLowerCase() + \"$lit$\").split(e),\n                    i = /([.?@])?(.*)/.exec(s);\n              c.push({\n                type: 1,\n                index: r,\n                name: i[2],\n                strings: t,\n                ctor: \".\" === i[1] ? M : \"?\" === i[1] ? H : \"@\" === i[1] ? I : S\n              });\n            } else c.push({\n              type: 6,\n              index: r\n            });\n          }\n\n          for (const i of t) l.removeAttribute(i);\n        }\n\n        if (g.test(l.tagName)) {\n          const t = l.textContent.split(e),\n                s = t.length - 1;\n\n          if (s > 0) {\n            l.textContent = i ? i.emptyScript : \"\";\n\n            for (let i = 0; i < s; i++) l.append(t[i], h()), A.nextNode(), c.push({\n              type: 2,\n              index: ++r\n            });\n\n            l.append(t[s], h());\n          }\n        }\n      } else if (8 === l.nodeType) if (l.data === o) c.push({\n        type: 2,\n        index: r\n      });else {\n        let t = -1;\n\n        for (; -1 !== (t = l.data.indexOf(e, t + 1));) c.push({\n          type: 7,\n          index: r\n        }), t += e.length - 1;\n      }\n\n      r++;\n    }\n  }\n\n  static createElement(t, i) {\n    const s = l.createElement(\"template\");\n    return s.innerHTML = t, s;\n  }\n\n}\n\nfunction P(t, i, s = t, e) {\n  var o, n, l, h;\n  if (i === b) return i;\n  let d = void 0 !== e ? null === (o = s._$Cl) || void 0 === o ? void 0 : o[e] : s._$Cu;\n  const u = r(i) ? void 0 : i._$litDirective$;\n  return (null == d ? void 0 : d.constructor) !== u && (null === (n = null == d ? void 0 : d._$AO) || void 0 === n || n.call(d, !1), void 0 === u ? d = void 0 : (d = new u(t), d._$AT(t, s, e)), void 0 !== e ? (null !== (l = (h = s)._$Cl) && void 0 !== l ? l : h._$Cl = [])[e] = d : s._$Cu = d), void 0 !== d && (i = P(t, d._$AS(t, i.values), d, e)), i;\n}\n\nclass V {\n  constructor(t, i) {\n    this.v = [], this._$AN = void 0, this._$AD = t, this._$AM = i;\n  }\n\n  get parentNode() {\n    return this._$AM.parentNode;\n  }\n\n  get _$AU() {\n    return this._$AM._$AU;\n  }\n\n  p(t) {\n    var i;\n    const {\n      el: {\n        content: s\n      },\n      parts: e\n    } = this._$AD,\n          o = (null !== (i = null == t ? void 0 : t.creationScope) && void 0 !== i ? i : l).importNode(s, !0);\n    A.currentNode = o;\n    let n = A.nextNode(),\n        h = 0,\n        r = 0,\n        d = e[0];\n\n    for (; void 0 !== d;) {\n      if (h === d.index) {\n        let i;\n        2 === d.type ? i = new N(n, n.nextSibling, this, t) : 1 === d.type ? i = new d.ctor(n, d.name, d.strings, this, t) : 6 === d.type && (i = new L(n, this, t)), this.v.push(i), d = e[++r];\n      }\n\n      h !== (null == d ? void 0 : d.index) && (n = A.nextNode(), h++);\n    }\n\n    return o;\n  }\n\n  m(t) {\n    let i = 0;\n\n    for (const s of this.v) void 0 !== s && (void 0 !== s.strings ? (s._$AI(t, s, i), i += s.strings.length - 2) : s._$AI(t[i])), i++;\n  }\n\n}\n\nclass N {\n  constructor(t, i, s, e) {\n    var o;\n    this.type = 2, this._$AH = w, this._$AN = void 0, this._$AA = t, this._$AB = i, this._$AM = s, this.options = e, this._$Cg = null === (o = null == e ? void 0 : e.isConnected) || void 0 === o || o;\n  }\n\n  get _$AU() {\n    var t, i;\n    return null !== (i = null === (t = this._$AM) || void 0 === t ? void 0 : t._$AU) && void 0 !== i ? i : this._$Cg;\n  }\n\n  get parentNode() {\n    let t = this._$AA.parentNode;\n    const i = this._$AM;\n    return void 0 !== i && 11 === t.nodeType && (t = i.parentNode), t;\n  }\n\n  get startNode() {\n    return this._$AA;\n  }\n\n  get endNode() {\n    return this._$AB;\n  }\n\n  _$AI(t, i = this) {\n    t = P(this, t, i), r(t) ? t === w || null == t || \"\" === t ? (this._$AH !== w && this._$AR(), this._$AH = w) : t !== this._$AH && t !== b && this.$(t) : void 0 !== t._$litType$ ? this.T(t) : void 0 !== t.nodeType ? this.k(t) : u(t) ? this.S(t) : this.$(t);\n  }\n\n  M(t, i = this._$AB) {\n    return this._$AA.parentNode.insertBefore(t, i);\n  }\n\n  k(t) {\n    this._$AH !== t && (this._$AR(), this._$AH = this.M(t));\n  }\n\n  $(t) {\n    this._$AH !== w && r(this._$AH) ? this._$AA.nextSibling.data = t : this.k(l.createTextNode(t)), this._$AH = t;\n  }\n\n  T(t) {\n    var i;\n    const {\n      values: s,\n      _$litType$: e\n    } = t,\n          o = \"number\" == typeof e ? this._$AC(t) : (void 0 === e.el && (e.el = E.createElement(e.h, this.options)), e);\n    if ((null === (i = this._$AH) || void 0 === i ? void 0 : i._$AD) === o) this._$AH.m(s);else {\n      const t = new V(o, this),\n            i = t.p(this.options);\n      t.m(s), this.k(i), this._$AH = t;\n    }\n  }\n\n  _$AC(t) {\n    let i = T.get(t.strings);\n    return void 0 === i && T.set(t.strings, i = new E(t)), i;\n  }\n\n  S(t) {\n    d(this._$AH) || (this._$AH = [], this._$AR());\n    const i = this._$AH;\n    let s,\n        e = 0;\n\n    for (const o of t) e === i.length ? i.push(s = new N(this.M(h()), this.M(h()), this, this.options)) : s = i[e], s._$AI(o), e++;\n\n    e < i.length && (this._$AR(s && s._$AB.nextSibling, e), i.length = e);\n  }\n\n  _$AR(t = this._$AA.nextSibling, i) {\n    var s;\n\n    for (null === (s = this._$AP) || void 0 === s || s.call(this, !1, !0, i); t && t !== this._$AB;) {\n      const i = t.nextSibling;\n      t.remove(), t = i;\n    }\n  }\n\n  setConnected(t) {\n    var i;\n    void 0 === this._$AM && (this._$Cg = t, null === (i = this._$AP) || void 0 === i || i.call(this, t));\n  }\n\n}\n\nclass S {\n  constructor(t, i, s, e, o) {\n    this.type = 1, this._$AH = w, this._$AN = void 0, this.element = t, this.name = i, this._$AM = e, this.options = o, s.length > 2 || \"\" !== s[0] || \"\" !== s[1] ? (this._$AH = Array(s.length - 1).fill(new String()), this.strings = s) : this._$AH = w;\n  }\n\n  get tagName() {\n    return this.element.tagName;\n  }\n\n  get _$AU() {\n    return this._$AM._$AU;\n  }\n\n  _$AI(t, i = this, s, e) {\n    const o = this.strings;\n    let n = !1;\n    if (void 0 === o) t = P(this, t, i, 0), n = !r(t) || t !== this._$AH && t !== b, n && (this._$AH = t);else {\n      const e = t;\n      let l, h;\n\n      for (t = o[0], l = 0; l < o.length - 1; l++) h = P(this, e[s + l], i, l), h === b && (h = this._$AH[l]), n || (n = !r(h) || h !== this._$AH[l]), h === w ? t = w : t !== w && (t += (null != h ? h : \"\") + o[l + 1]), this._$AH[l] = h;\n    }\n    n && !e && this.C(t);\n  }\n\n  C(t) {\n    t === w ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t ? t : \"\");\n  }\n\n}\n\nclass M extends S {\n  constructor() {\n    super(...arguments), this.type = 3;\n  }\n\n  C(t) {\n    this.element[this.name] = t === w ? void 0 : t;\n  }\n\n}\n\nconst k = i ? i.emptyScript : \"\";\n\nclass H extends S {\n  constructor() {\n    super(...arguments), this.type = 4;\n  }\n\n  C(t) {\n    t && t !== w ? this.element.setAttribute(this.name, k) : this.element.removeAttribute(this.name);\n  }\n\n}\n\nclass I extends S {\n  constructor(t, i, s, e, o) {\n    super(t, i, s, e, o), this.type = 5;\n  }\n\n  _$AI(t, i = this) {\n    var s;\n    if ((t = null !== (s = P(this, t, i, 0)) && void 0 !== s ? s : w) === b) return;\n    const e = this._$AH,\n          o = t === w && e !== w || t.capture !== e.capture || t.once !== e.once || t.passive !== e.passive,\n          n = t !== w && (e === w || o);\n    o && this.element.removeEventListener(this.name, this, e), n && this.element.addEventListener(this.name, this, t), this._$AH = t;\n  }\n\n  handleEvent(t) {\n    var i, s;\n    \"function\" == typeof this._$AH ? this._$AH.call(null !== (s = null === (i = this.options) || void 0 === i ? void 0 : i.host) && void 0 !== s ? s : this.element, t) : this._$AH.handleEvent(t);\n  }\n\n}\n\nclass L {\n  constructor(t, i, s) {\n    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = i, this.options = s;\n  }\n\n  get _$AU() {\n    return this._$AM._$AU;\n  }\n\n  _$AI(t) {\n    P(this, t);\n  }\n\n}\n\nconst R = {\n  L: \"$lit$\",\n  P: e,\n  V: o,\n  I: 1,\n  N: C,\n  R: V,\n  j: u,\n  D: P,\n  H: N,\n  F: S,\n  O: H,\n  W: I,\n  B: M,\n  Z: L\n},\n      z = window.litHtmlPolyfillSupport;\nnull == z || z(E, N), (null !== (t = globalThis.litHtmlVersions) && void 0 !== t ? t : globalThis.litHtmlVersions = []).push(\"2.2.2\");\nexport { R as _$LH, $ as html, b as noChange, w as nothing, x as render, y as svg }; //# sourceMappingURL=lit-html.js.map","map":null,"metadata":{},"sourceType":"module"}